# О чём это

Как сделать страницы на Bitrix **полностью в своём дизайне** двумя способами:

* **HTML‑внутри Bitrix** — всё рендерит Bitrix, вы пишете свою вёрстку.
* **React отдельно (headless)** — фронт и бэкенд живут отдельно, релизятся независимо.
  Без «островов», без лишней терминологии.

---

# Куда мы идём (в 2 словах)

* **Путь 1: HTML‑внутри Bitrix.** Вы берёте стандартные компоненты, но им делаете **свои шаблоны** (свой HTML/CSS/JS). В итоге страницы выглядят ровно как в макете.
* **Путь 2: React‑фронт отдельно.** Bitrix отвечает за данные и логику (админка/корзина/каталог), а **фронт — это отдельный проект** (Next.js/Vite). Он ходит к Bitrix за данными по URL и сам рисует страницы.

---

# Путь 1. HTML‑внутри Bitrix (просто и быстро)

## Что это даёт

* Полный контроль над разметкой и стилями.
* Ничего не ломаем в ядре Bitrix (обновления не страшны).

## Куда класть файлы

```
/local/templates/<имя_шаблона>/            ← ваш «сайт‑шаблон»: шапка, подвал, стили
  assets/                                   ← ваши CSS/JS/шрифты/картинки
  components/bitrix/<компонент>/<шаблон>/   ← ваши шаблоны стандартных компонентов
```

Главное правило: **всё своё — в /local** (не в /bitrix).

## Как «надеть» свой дизайн на компонент

1. В админке найдите компонент, который рисует нужный блок (список новостей, товары и т.д.).
2. Скопируйте его шаблон к себе: `/local/templates/<имя>/components/bitrix/<компонент>/<имя_шаблона>/`.
3. В настройках компонента выберите ваш `<имя_шаблона>`.
4. Откройте `template.php` и напишите **свой HTML** (классы, BEM — как в макете).
5. Если данные «кривые» или их надо подготовить — в файле `result_modifier.php` вы их **приводите к удобному виду** (например, собрать заголовок, отформатировать цену).

### Мини‑пример

**template.php**

```php
<?php if (!defined('B_PROLOG_INCLUDED') || B_PROLOG_INCLUDED!==true) die(); ?>
<ul class="product-grid">
  <?php foreach ($arResult['ITEMS'] as $it): ?>
    <li class="product">
      <a href="<?=htmlspecialcharsbx($it['URL'])?>" class="product__link">
        <img src="<?=htmlspecialcharsbx($it['IMG'])?>" alt="" class="product__img">
        <span class="product__title"><?=htmlspecialcharsbx($it['TITLE'])?></span>
        <span class="product__price"><?=$it['PRICE']?></span>
      </a>
    </li>
  <?php endforeach; ?>
</ul>
```

**result_modifier.php**

```php
<?php foreach ($arResult['ITEMS'] as &$it) {
  $it['TITLE'] = $it['~NAME'] ?? '';
  $it['URL']   = $it['DETAIL_PAGE_URL'] ?? '#';
  $it['IMG']   = $it['PREVIEW_PICTURE']['SRC'] ?? '/local/templates/<имя>/assets/img/plug.svg';
  $priceRaw    = (float)($it['PROPERTIES']['PRICE']['VALUE'] ?? 0);
  $it['PRICE'] = number_format($priceRaw, 0, '.', ' ').' ₽';
}
```

### Стили и скрипты

Добавляйте в `header.php` вашего шаблона сайта:

```php
use Bitrix\Main\Page\Asset;
Asset::getInstance()->addCss(SITE_TEMPLATE_PATH.'/assets/css/app.css');
Asset::getInstance()->addJs(SITE_TEMPLATE_PATH.'/assets/js/app.js');
```

### Как проверить

* Страница открывается — выглядит как макет.
* Вёрстка идёт из ваших файлов в `/local/templates/...`.
* Никаких «лишних» дивов/классов от Bitrix — всё ваше.

### Частые ошибки

* Поменяли файлы в `/bitrix` → при обновлении всё пропало. Делайте **только в /local**.
* Пихаете обработку данных в HTML → выносите в `result_modifier.php`.
* Стили подключаете тегами `<link>` в шаблонах компонентов → лучше через `Asset::getInstance()` в шаблоне сайта.

---

# Путь 2. React отдельно (headless, независимые релизы)

## Что это даёт

* Фронт живёт своей жизнью: отдельный репозиторий, любые современные фреймворки и сборки.
* Обновляете фронт без касания Bitrix.

## Как это устроено в целом

* **Bitrix** отдаёт **данные** по URL (например: `/bitrix/services/main/ajax.php?action=shop.api.products.list`).
* **React‑приложение** (например, Next.js) делает запросы на эти URL и **рисует** страницы само.

## Что сделать на стороне Bitrix

1. Создать «ручки» для данных (простые методы‑адреса). В Bitrix они называются **контроллеры** и **действия**.
2. В методе достаём товары/посты и возвращаем **чистый массив**, Bitrix сам отдаст его как JSON.

**Очень короткий пример «ручки» (упрощённо):**

```php
class Catalog extends BitrixController {
  public function listAction($page = 1, $limit = 20) {
    // тут берём данные из инфоблоков/HL и т.д.
    return [
      'items' => [ /* ...товары... */ ],
      'page'  => (int)$page,
      'limit' => (int)$limit,
      'total' => 123,
    ];
  }
}
```

После подключения такой «ручки» вы сможете получить JSON по адресу типа:

```
/bitrix/services/main/ajax.php?action=shop.api.catalog.list&page=1
```

## Что сделать на стороне React (Next.js)

* Завести переменную окружения `NEXT_PUBLIC_API_ORIGIN` (где крутится Bitrix).
* Написать маленькую функцию для запросов:

```ts
export async function api(action: string, params: Record<string,string|number> = {}) {
  const url = new URL('/bitrix/services/main/ajax.php', process.env.NEXT_PUBLIC_API_ORIGIN);
  url.searchParams.set('action', action);
  for (const [k,v] of Object.entries(params)) url.searchParams.set(k, String(v));
  const res  = await fetch(url.toString(), { credentials: 'include' });
  const json = await res.json();
  if (json.status !== 'success') throw new Error('API error');
  return json.data;
}
```

* На странице:

```tsx
const data = await api('shop.api.catalog.list', { page: 1 });
```

* Дальше — просто рисуем свои компоненты и страницы как в обычном React‑проекте.

## Авторизация и «куки» (простыми словами)

* **Фронт и Bitrix на одном домене/поддоменах** → всё просто, `credentials: 'include'` и работает.
* **На разных доменах** → нужно разрешить запросы с фронта на бэкенд (включают «CORS» в Bitrix) и настроить куки так, чтобы они ходили между доменами (флаг `SameSite=None; Secure`). Это делает ваш разработчик/админ.

## Где хранить картинки/файлы

* Либо отдаём прямые ссылки Bitrix, либо используем CDN. Для загрузок делаем отдельный адрес («ручку»), где проверяются права и размер файла.

## Как выпускать отдельно

* **Фронт**: свой репозиторий, сборка и деплой (Vercel/Docker/сервер).
* **Bitrix**: свой деплой (как обычно). Важное правило — **не ломать адреса «ручек» и формат ответа**.

### Частые ошибки

* Меняют структуру ответа API без предупреждения → фронт падает. Решение: договориться и «заморозить» ответ (простая схема полей), если нужен редизайн — делайте `v2`.
* Слишком тяжёлые ответы (10000 товаров за раз) → пагинация: отдаём порциями.
* Фронт и бэкенд на разных доменах, а куки не ходят → включить CORS и `SameSite=None; Secure`.

---

# Когда что выбрать

* **Нужно быстро и всё в Bitrix** → HTML‑внутри Bitrix.
* **Нужен современный фронт, независимые релизы, гибкий роутинг** → React отдельно (headless).

---

# Короткие чек‑листы

## HTML‑внутри Bitrix

* [ ] Все файлы только в `/local`.
* [ ] У каждого компонента свой шаблон в `/local/templates/.../components/bitrix/...`.
* [ ] Данные готовим в `result_modifier.php`, а не в HTML.
* [ ] Стили/скрипты подключаем в шаблоне сайта через `Asset::getInstance()`.

## React отдельно

* [ ] На Bitrix есть «ручки» для нужных данных.
* [ ] Ответы простые и стабильные (список полей согласован).
* [ ] Во фронте есть функция `api(...)` и адрес Bitrix.
* [ ] Если домены разные — включён CORS и настроены куки.

---

# План запуска (минимум действий)

1. Выберите путь: **HTML** или **React отдельно**.
2. Подготовьте макеты и список страниц/блоков.
3. Сделайте по одной «эталонной» странице.
4. Проверьте данные/ответы (что приходит, какие поля нужны).
5. Заводите остальные страницы по шаблону.

Если нужно — могу приложить готовые заготовки папок/файлов под ваш проект и расписать пошагово под ваши конкретные сущности: каталог, корзина, блог, личный кабинет.
